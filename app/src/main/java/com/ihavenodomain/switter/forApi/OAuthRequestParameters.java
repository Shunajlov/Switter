package com.ihavenodomain.switter.forApi;

import android.util.Base64;

import com.ihavenodomain.switter.ActivityMain;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.Random;

/**
 * Данные, необходимые для авторизации запросов к API
 * https://dev.twitter.com/oauth/overview/authorizing-requests
 * Пример:
        Connection: close
        User-Agent: OAuth gem v0.4.4
        Content-Type: application/x-www-form-urlencoded
        Authorization:
        OAuth oauth_consumer_key="xvz1evFS4wEEPTGEFPHBog",
        oauth_nonce="kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg",
        oauth_signature="tnnArxj06cWHq44gCs1OSKk%2FjLY%3D",
        oauth_signature_method="HMAC-SHA1",
        oauth_timestamp="1318622958",
        oauth_token="370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb",
        oauth_version="1.0"
        Content-Length: 76
        Host: api.twitter.com

        status=Hello%20Ladies%20%2b%20Gentlemen%2c%20a%20signed%20OAuth%20request%21
 *
 */

public class OAuthRequestParameters {
    /**
     * The oauth_consumer_key identifies which application is making the request.
     * Obtain this value from checking the settings page for your application on dev.twitter.com/apps.
     * Пример: xvz1evFS4wEEPTGEFPHBog
     */
    private String consumerKey;

    /**
     * The oauth_nonce parameter is a unique token your application should generate for each unique request.
     * Twitter will use this value to determine whether a request has been submitted multiple times.
     * The value for this request was generated by base64 encoding 32 bytes of random data,
     * and stripping out all non-word characters, but any approach
     * which produces a relatively random alphanumeric string should be OK here.
     * Пример: kYjzVBB8Y0ZFabxSWbWovY3uYSQ2pTgmZeNu2VS4cg
     */
    private String nonce;

    /**
     * The oauth_signature_method used by Twitter is HMAC-SHA1.
     * This value should be used for any authorized request sent to Twitter’s API.
     */
    private String signatureMethod;

    /**
     * The oauth_signature parameter contains a value which is generated by running all of the other
     * request parameters and two secret values through a signing algorithm.
     * The purpose of the signature is so that Twitter can verify that
     * the request has not been modified in transit, verify the application sending the request,
     * and verify that the application has authorization to interact with the user’s account.
     * https://dev.twitter.com/oauth/overview/creating-signatures
     */
    private String signature;

    /**
     * The oauth_timestamp parameter indicates when the request was created.
     * This value should be the number of seconds since the Unix epoch at the point the request
     * is generated, and should be easily generated in most programming languages.
     * Twitter will reject requests which were created too far in the past,
     * so it is important to keep the clock of the computer generating requests in sync with NTP.
     */
    private String timestamp;

    /**
     * The oauth_token parameter typically represents a user’s permission to share access
     * to their account with your application. There are a few authentication requests
     * where this value is not passed or is a different form of token,
     * but those are covered in detail in Obtaining access tokens.
     * https://dev.twitter.com/oauth/overview
     * For most general-purpose requests, you will use what is referred to as an <b>access token</b>.
     * You can generate a valid access token
     * for your account on the settings page for your application at dev.twitter.com/apps
     */
    private String token;

    /**
     * The oauth_version parameter should always be 1.0 for any request sent to the Twitter API.
     */
    private String version;

    private String consumerSecretUtf8;
    private String accessTokenSecretUtf8;

    private String httpMethod;
    private String baseUrl;

    public OAuthRequestParameters(String httpMethod, String baseUrl) {
        // Это нужно для создания подписи (signature)
        this.httpMethod = httpMethod;
        this.baseUrl = baseUrl;

        // Вы будете смеяться, но их ещё нужно по алфавиту отсортировать перед отправкой
        consumerKey = ActivityMain.CONSUMER_KEY;
        setNonce();
        signatureMethod = "HMAC-SHA1";
        setTimestamp();
        token = ActivityMain.ACCESS_TOKEN;
        version = "1.0";
        setSignature(); // signature требует всех описанных выше параметров
    }

    private void setTimestamp() {
        timestamp = String.valueOf(System.currentTimeMillis() / 1000L);
    }

    private void setNonce() {
        byte[] r = new byte[32];
        new Random().nextBytes(r);
        nonce = Base64.encodeToString(r, Base64.NO_WRAP);
        nonce = nonce.replaceAll("[^\\p{L}\\p{Nd}]+", "");
    }

    /**
     * wow, such signature algorithm
     */
    private void setSignature() {
        prepareParameters();
        /**
         * The signing key is simply
         * the percent encoded consumer secret,
         * followed by an ampersand character ‘&’,
         * followed by the percent encoded token secret
         */


        //?screen_name=KremlinRussia&count=15
        String signatureBaseString = httpMethod + "&" + baseUrl + "&";
        String parameterString =
//                "count=15" + "&" +
                "oauth_consumer_key=" + consumerKey + "&" +
                "oauth_nonce=" + nonce + "&" +
                "oauth_signature_method=" + signatureMethod + "&" +
                "oauth_timestamp=" + timestamp + "&" +
                "oauth_token=" + token + "&" +
                "oauth_version=" + version + "&";// +
//                "screen_name=KremlinRussia";
        try {
            parameterString = URLEncoder.encode(parameterString, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        signatureBaseString += parameterString;

        String signingKey = consumerSecretUtf8 + "&" + accessTokenSecretUtf8;
        try {
            // Calculating the signature
            signature = HmacSha1Signature.calculateRFC2104HMAC(signatureBaseString, signingKey);
            signature = Base64.encodeToString(signature.getBytes(), Base64.NO_WRAP);
        } catch (Exception e) {
            signature = "kekWrongSignatureMaaan";
            e.printStackTrace();
        }
    }

    private void prepareParameters() {
        /**
         * Pay particular attention to the percent encoding of the values when building this string.
         * For example,
         * the oauth_signature value of tnnArxj06cWHq44gCs1OSKk/jLY=
         * must be encoded as tnnArxj06cWHq44gCs1OSKk%2FjLY%3D
         */
        try {
            httpMethod = httpMethod.toUpperCase();
            baseUrl = URLEncoder.encode(baseUrl, "UTF-8");
            consumerSecretUtf8 = URLEncoder.encode(ActivityMain.CONSUMER_SECRET, "UTF-8");
            accessTokenSecretUtf8 = URLEncoder.encode(ActivityMain.ACCESS_TOKEN_SECRET, "UTF-8");
            consumerKey = URLEncoder.encode(consumerKey, "UTF-8");
            nonce = URLEncoder.encode(nonce, "UTF-8");
            signatureMethod = URLEncoder.encode(signatureMethod, "UTF-8");
            timestamp = URLEncoder.encode(timestamp, "UTF-8");
            token = URLEncoder.encode(token, "UTF-8");
            version = URLEncoder.encode(version, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
    }

    /**
     * Не забудь вставить заголовок Authorization
     * @return string ready for response
     */
    public String getHeaderParameters() {
        try {
            signature = URLEncoder.encode(signature, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return "OAuth " +
                "oauth_consumer_key=\"" + consumerKey + "\"," +
                "oauth_nonce=\"" + nonce + "\"," +
                "oauth_signature=\"" + signature + "\"," +
                "oauth_signature_method=\"" + signatureMethod + "\"," +
                "oauth_timestamp=\"" + timestamp + "\"," +
                "oauth_token=\"" + token + "\"," +
                "oauth_version=\"" + version + "\"";
    }
}
